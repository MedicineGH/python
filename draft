 

主要负责短信平台与运营商接口服务管理，及时响应，及时处理；
负责日常短信服务的监控、运营商骨干网络波动，及时响应，及时转接备用通道，故障割接等；

    网络割接又叫网络迁移，是指运行网络物理或者逻辑上的更改。
      网络割接前的准备工作大致包含：通知相关部门和客户，人员分工，准备割接材料，同步备份数据，信息采集，割接后确认测试。
负责平台层面、性能维护、功能更新、短信服务稳定运行等；
负责推动运维自动化工作，不断完善短信服务自动更新、报警自动处理、参与 CMDB 模块设计开发等；

Redis三大特点：
    Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
    Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
    Redis支持数据的备份，即主从(master-slave)模式的数据备份。
    性能极高 – Redis能读的速度是11W次/s,写的速度是8W1千次/s 。

任务调度系统
  传统人工执行任务非常没有效率，公司利用脚本化管理服务器，随着公司的发展节点越来越多，不能单凭工具堆积解决问题，因为局限性，某个工具只能解决某种特定的
  问题，我们必须把这些工具有机的集合在一起，编写任务调度系统进行维护。
  
  
  分发任务设计，采用有Agent，采用C/S架构，分为WebServer、Master、Agent。
    有Agent与无Agent的区别：

    有Agent，被控节点需要安装或运行特殊的软件，也就是说自己写个软件在那，你跟它通信把任务分给它由它来执行我们称为Agent(代理人)，和服务器端通信，服务
    器端把脚本、命令传给Agent端，由Agent来控制执行。
    无Agent，被控节点不需要安装或运行特殊的软件，列如通过ssh。这其实也是有Agent，不过Agent就是通过ssh，不是自己写的程序。
    通用、简单、易实现。但管理不善，容易出安全问题。
    
    
  与master之间通信模块实现
    Agent和Master之间是要通信的，底层都得通过Socket实现的，但Socket太底层了用起来特别不方便，得解决send来来回回的、序列化的问题、ancode、decode
    一些的问题。这里要解决网络通信问题，还有序列化问题。
    
    Master和Agent之间采用RPC通信，使用zerorpc模块它是一个轻量级，跨语言的RPC通信，它基于ZeroMQ和MessagePack之上，不但实现网络通信，
    还搞定了序列化反序列化问题。
    zerorpc模块说到底它是RPC通讯因为它对数据做了序列化反序列化，也就是说它实际上有通讯协议的，而且替我实现了两端接口定义，以及两端接口匹配的问题
    
    Messagepack(是一个基于二进制高效的对象序列化类库，用于跨语言通讯)
    ZeroMQ是一种基于消息队列的多线程网络库，提供跨越多种传输协议。
        消息队列：在高并发环境下，由于来不及同步处理，请求往往会发生堵塞
        
        消息被发送到队列中。“消息队列”是在消息的传输过程中保存消息的容器。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。
        队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。
        
        “消息队列网络”是能够相互间来回发送消息的任何一组计算机。网络中的不同计算机在确保消息顺利处理的过程中扮演不同的角色。它们中有些提供路由信息
        以确定如何发送消息，有些保存整个网络的重要信息，而有些只是发送和接收消息。
        
        异步：多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线
        
        同步：多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行， 只有一个主线
 
        阻塞：从调用者的角度出发，如果在调用的时候，被卡住，不能再继续向下运行，需要等待，就说是阻塞
 
        非阻塞： 从调用者的角度出发， 如果在调用的时候，没有被卡住，能够继续向下运行，无需等待，就说是非阻塞
        
        每一个进程都认为自己独占所有的计算机硬件资源。进程就是独立的王国，进程间不可以随便共享数据。
        线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的堆栈。
        
        并行(parallel)：同时做某些事，可以互不干扰的同一时刻做很多事情。
        举例：高速公路的车道，双向4车道，所有车辆(数据)可以互不干扰的在自己的车道上奔跑(传输)
        
        并发(concurrency)：同一时段做了几件事。
    
    所以它叫zerorpc，rpc又叫远程过程调用，实际上是远程的过程中的哪些线程里面某一个类或者说方法或者说某个函数的调用。说到底都是这种调用，它们都是
    一致的，总之通过网络，通过某种协议，大家交互然后我在远程节点上让它帮我去执行某些函数，所以这就是远程过程调用。
    
    
    
    任务执行流程：
          当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中参数的值要序列化
          成二进制的形式，也就是序列化或编组，通过寻址和传输将序列化的二进制发送给B服务器。
          
          B服务器收到请求后，需要对参数进行反序列化，恢复为内存中的表达式，然后找到对应的方法(寻址)进行本地调用，然后得到返回值。
          返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A收到后，再反序列化，恢复为内存中的表达式，交给A服务器上的应用。
    
  
    
  Web与Master使用TCP连接，任务调度系统内部都是TCP连接。
    短连接：
  短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。
  
    长连接：
  长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。
  
    TCP三次握手：
    简述：
        A与B建立TCP连接时：首先A向B发SYN(同步请求)，然后B回复SYN+ACK(同步请求应答)，最后A回复ACK确认，这样TCP的三次握手就建立了！
        
    TCP四次挥手：
    简述：
    1、客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
    
    2、服务器B收到这个FIN，它回复一个ACK和SYN加1，一个FIN将占用一个序号。
    
    3、服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
    
    4、客户端A回复ACK报文确认，并将确认序号设置为收到序号加1，就结束了这次的TCP连接。
  
  为什么四次挥手？
    因为通过四次挥手，保证数据的完整性，将未传完的数据传完后断开连接。
    
  Master管理Agent，接收用户提交任务，实现任务调度。
    在Web上定义好跟前端交互的API(接口)，就相当于URL路由(默认路由)，把URL路由暴露出来就行了，对方通过URL就可以访问不同的方法，然后执行相应的内容。
    如果说现在增加一个任务过来相当于Web调用一个API，这个API内部就相当于把任务通过TCP协议加到Master上Master有个任务列表把任务指派给Agent1、2执行之
    后分别返回结果，先到Master交互给Web再给client。
  
  
  
  接口(API)
    接口就是提供的方法，能让对方访问，调用，操作的都可以称为接口。
    
    
  遇到的问题：

　　1.在写Message模块中测试时，Client连接不上Server，最终通过排查发现使用netifaces获取
    IP地址时出现异常返回的是IP对象，最终需要的str(ip)解决问题。

　　2.在使用zerorpc的clinet请求时,server端会出现以下异常

 　　zerorpc。通道多路复用器在recv上忽略错误

　　解决方法是：

　　检查代码逻辑并确认代码内的数据对象类型都没有问题。

　　pip uninstall msgpack-python

　　# 卸载messagepack在重装zerorpc

　　pip install zerorpc
  
  
  最终用户用浏览器构建任务并提交任务，Web调用一个API，这个API内部就相当于把任务通过TCP协议加到Master上Master
  把任务指派给谁，派给Agent1、2执行之后分别返回结果，先到Master交互给Web再给client。
  

CMDB资产管理
    项目负责：关系模型建立，Service层的日志配置及接口功能实现
    
    项目描述：
    在资产管理前期，解决资源存储凌乱需要把大家分散存储信息，Excel表格、云笔记、甚至纸质的，各种软硬件基本信息集中管理起来。如IP、交换机、主机等等。
    
    我们利用Mysql提供的Workbench工具主要在这里做一些模型的设计。通过图形化构建数据库之间的关系。
    问你们CMDB做的什么东西呀？
    我们当时很原始的，什么都没有乱七八糟的，有的写在本上的、有的是存在Mysql数据库的、甚至有的用临时存、还有用Excel的最多了这么乱怎么办呢？
    然后找了几个同事我们说这个东西一定要管理起来，不然管理不方便，然后我们就开始考虑怎么写了，我们最熟悉的就是python了，然我们搞个DB设计也搞不出来，
    怎么办呢？我们就基于我们的Mysql来搞。我们用Mysql刚开始是要做设计的，我先建了一些主机表把主机管理起来了，感觉东西少，然后我们还管理一些路由器，
    后来其它同事说他也有些硬件资产需要管理在建两张表，这是我们最原始的建设方式，我们建了十来张表把这些资产都管理起来了，用的也挺好的，起码我们查起来
    方便多了。但是问题来了，有同事说某个IP需要迁移到另一台机器上去，这就麻烦了，IP在一个小范围内它是唯一的，IP迁移之后它是一个IP池的管理，我们当时
    都没考虑这东西，我们就是记资产都没把IP当它是资产，后来我们又把IP引进来了，因为IP你用了，别人就不能用了，不然在一个范围之内就冲突了。
    
   
    
    通过传统的方式把这些一个一个表建起来没有问题，但是在我们可以想到的范围之内，发现这种设计带来了很大的问题，1、字段真的没法控制了，不但增加字段
    甚至还要减少字段。然后管理资产越多表就会变的越来越多根本不可控的。所以传统设计扩展性极差，而且大量字段冗余，没办法每张表一个字段这就是传统表带
    来的一些问题。
    
    当时只能叫信息化，现在我们想做一个真正能够记录这种资产信息的CMDB。

　　我们要做这个不是说我们要真正实现一个Mysql或Oracle这样的数据管理，而是基于它们之上，做设计，我们要充分的考虑运维日常管理的信息复杂性，管理的东西
    太多了，谁也不知道明天会有什么东西要加进来？根本都不清楚，而且字段也变，表也变，我们能不能用一种特殊设计来实现它？
    
    就说我们要管理的信息其实就是表、字段，关系模型就是表、字段于它之间的关系，我们能不能把它拆开？
    也就说表在一个地方放着，字段在一个地方放着，以后通过这张表找这个字段就完了，那这个字段随便添，它不影响这张表，到时找这张表的时候字段任意扩展，
    合在一起是一张整个表。
    传统表里面记录可以无限随便添，我们想添的无非就是主机表、交换机表、路由表，它的字段可能也会变化，也要添，既然你们都要变就拆开，一张表里描述主机表、
    或什么表光描述它，一张表里光描述字段这就拆开了，分家了，你要填张表无非就是在当前表里添一个主机表，但它字段在另一张表里专门放字段添就完了。
    就是这种思想。

    基于Mysql实现，大家见的多了，还用的较熟，我们就用它来实现，用传统关系型数据库能不能实现我们需求呢？我们就尝试的做一下，我们首先想到了既然表、字段
    都不知道要建多少个，这样的话我想办法把你拆开的把原来一列列的事情，改成一行行，我们现在关系型数据库就叫行存数据库，对它来说天生允许存一行行，它也
    能存一列列，但它的列一旦做了就叫固定列了它不能任意动，虽然它可以添加，相当于在改表的源数据结构，不是说做不到代价很高，关系型数据库它是张二维表，
    我的列是固定的，一行行可以加，但是一列列就别乱动了，所以它当初设计的时候就是为了解决这样的问题。
    
    那你非得在这张表上换来换去经常给它多增列来回变，它不适合，我们能不能把一列列变动的东西变成一行行变动的东西，这就是我们的目标，由此我们做了一些
    考虑，尤其第一张表和第二张表的这种思考是比较麻烦的，我们用这种方式建了第一张表，我们用这种方式建了第一张表，然后我们就思考表的字段应该怎么办? 
    我们发现字段放在这张表里不合适，我们能不能建一张字段表，如果建字段表的话它跟Schema表应该建立一种关系而这种关系怎么来描述呢？我们发现只要告诉我
    是你那张表的字段就完了么，我们就在想在Field表里面增加个外键关联一下就行了。所以就有了schema+field描述出一张逻辑表，但这个表只是个逻辑表的定义，
    数据还不在这，可以认为表的源数据定义好，但表的实际数据不在这也不适合在这存，所以这个时候我们就想这个原数据怎么办？如果你要存一个数据应该怎么做？
    我们说一个表定义好了要在里面放一条数据，这条数据其实有个隐含条件它实际是说这条数据是这张表的，那这张表的到底是什么东西，我们说现在有个schema_id
    把schema_id要记录下来不就是说这条记录就是这张表的么，这种关系刚好是一一对应的问题，一条记录只能关联到某一张表上去，但你说一张表到底有多少条记录
    呢？这个不好说，所以它总体的关系应该是一对多的，但是从(entity)记录这边往过看我这条记录明确的属于某一张表，而那张表是怎么描述的？我们讲唯一的东西
    就可以描述，所以主键的好处就在这了，我们由此想到了实体表(entity)，有实体表我们就可以来描述一条记录，但是因为字段的特殊性我们放在这张表里也不合
    适，我们就想着字段应该怎么做，这时候字段应有很多的，一条记录有好几个字段，每个字段都应该记录下来，怎么记录呢? 我还是把一列列事情变成一行行，但是
    放在当前这张表不合适，所以我们又引出了一张表，这张表可以认为放值的，我们说怎么描述这些问题呢？实际上就应该说你建的这一个记录应该属于那张逻辑表里
    面的第几行里面每一个数值应该属于第几个字段，就说本质上跟schema_id和field_id是有关系的，但是我们中间多了个antity，而antity跟schema之间又一对多
    的关系，从entity往schema上看是一一对应的，有这样的一对一的关系我们实际在value表就没必要添那么多东西了，就放entity表就相当于填了个schema_id，
    那字段怎么办？我那知道是那个字段，所以字段表必须也引入过来，字段表引用过来后就相当于vaule表又多了个外键，当然每一张表上还要放一些其它描述性数据
    那你就在每一张表上填一些字段就行了。
    
    我们现在用四张表来解决我们现在所谓的一个表以及它所谓的虚拟表以及它的记录，我们搞定了能把这些数据存下来，而且可以描述这个东西。
    
    我们现在这种设计你随便加字段，我们说物理表加个字段的话整个表的物理存储结构发生很大变化，因为加字段和加记录是两码事儿，因为这种行存数据库加记录是
    没事儿的，当然撑爆了那没办法，但一般来讲它天生要加一行行记录，但是要加字段这事儿可不能长做，影响太大了，如：加字段可以理解为货架够了，你把货架子
    加一列把，得把墙拆了，影响很大，行存数据库就是允许你加行的，你要加列整个每一行的存储都要改变，影响非常大。

    好处

 　　不管需要多少配置项，需要就在schema表中添加，就是说在以前每一类我们都会把它生成张表，现在无所谓了添host、填ipaddess、填一个管机架的，无非就是
     在schema里面添了一行记录而已。

　　不管配置项有多少属性字段，需要就在field表中增加即可。所以把以前把增加表和表里增加字段的情况全部变成了增加记录，增加行这种方式了。

　　坏处

　　我们为了实现存储数据，连设计它的原数据存储以及它的数据存储，我们用四张表，表结构复杂了，关系复杂了，原来一张张表变成了多张表的关系。
    复杂的同时，带来了灵活。


    外键约束（它一定在两张表当中，而且必须有主键出现，没有主键就没有外键），为了保证数据完整性、一致性，杜绝数据冗余、数据讹[é]误。
    
    
    Mysql隔离级别：
        Mysql是可以重复读
        Oreacle是读已提交
    
SQLAlchemy它是一种提供数据映射器模式的可选组件，其中类可以以开放式，多种方式映射到数据库 - 允许对象模型和数据库模式在从一开始就干净地解耦。





短信服务：
  我这边有一些提供短信接口的服务---->服务提供api接口
  这些短信服务器上提供短信接口--->1 2 3 4 5 等，第三方来调用这些接口时候，我api推送到调用的应用方这需要使用推送这个脚本
  
  
企业应用层--->短信服务器---->运营商网关---->手机客户
                    |         |
                    |         |
                   第三方通道方  
                   

短信下发流程：
  前台调用接口====》接口把短信放到redis缓存队列===》网关redis获取数据===》运营商把短信发送状态、上行等数据发送到网关===》通过运营商网关http、
  cmpp、sgip、smpp等协议，把数据发送给通道运营商，最终把短信发给用户。


elk方案问题
    1、运维成本高，每增加一个日志收集，都需要手动修改配置
    2、监控缺失，无法准确获取logstash的状态
    3、无法做定制化开发以及维护


什么是io密集和cpu密集？
    IO密集是大量读写
    CPU密集是大量计算
    
Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block
（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。

Nginx的模块从结构上分为核心模块、基础模块和第三方模块：

核心模块：HTTP模块、EVENT模块和MAIL模块

基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块，

第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。

用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。

Nginx的模块从功能上分为如下三类。

Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。

Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。

Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。
    
    

1.HTTP的概述
    超文本传输协议(HTTP)是万维网应用层的协议，是通过两端实现：一个是客户端(一般为浏览器)，另一个是服务器(Web服务器)。
    这两个通常运行在不同的主机上通过交换HTTP报文来完成网页请求和响应。并且HTPP定义了报文的结构和客户端/服务器之间交换报文的规则。
2.HTTP的工作流程
    浏览器可以向Web服务器发送请求并显示收到的网页，当用户在浏览器地址栏中输入一个URL或点击一个超链接时，浏览器就向服务器发出了HTTP请求，该请求
    被送往由URL指定的Web服务器，Web服务器收到请求后，进行相关文档的检索并以HTTP规定的格式送回所要求的文件或其它相关信息，再由客户计算机上的浏览器
    负责解释和显示。
    在HTTP协议中，由于Web服务器在发送用户请求的文档过程中，并不存储任何有关客户端的状态信息。如果某个客户端在几秒钟内两次请求同一个文档，服务器
    绝对不会认为不合理，因为它根本不记得用户端曾经来访过，因此HTTP不维持客户端状态，故它又被称为无状态协议。
    
3.2 提高HTTP服务效率的两种方法
    1.从一个客户端同是发送多个TCP连接并列到一个Web服务器上，及建立“并行”的TCP连接，目前浏览器可以配置5-10个并行连接，每个连接完成一次HTTP的报文交
    换，但其没有从根本上解决服务器负担问题。
    2.使用持续连接模式，服务器在完成一次HTTP报文交互后继续保持连接，统一客户端和服务器之间后继的请求和响应报文可以在原来的连接进行。
    
    
Python的第三方模块：
    BeautifulSoup：用于解析html代码，方便提取所需内容
    xlwt:用于将数据写入到excel文件
    pymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。
    SQLAlchemy是Python SQL工具包和对象关系映射器，为开发人员提供了SQL的全部功能和灵活性。它提供了一整套企业级持久性模式，专为高效和高性能的
    数据库访问而设计。
    
    
消息队列：
    “消息队列”是在消息的传输过程中保存消息的容器。

为什么从上家公司离职：
  公司发展比较稳定，但我还年轻，希望有更大的挑战和更多的学习机会。

你会选择创业公司还是像BAT那样的大公司，为什么？
  创业公挑战大，享受挑战；创业公司具有无限成功的可能性，想随公司一起成长；

  
